```python
import numpy as np
```


```python
names=np.array(['Bob','Joe','Will','Bob','Joe','Will'])
```


```python
names=='Bob'
```




    array([ True, False, False,  True, False, False])




```python
data=np.random.randn(6,4)
```


```python
data
```




    array([[-1.7629997 ,  0.08579372, -0.88277514, -1.14132668],
           [ 1.43614565,  1.27858212, -2.10666404, -0.30492433],
           [ 0.33015614,  0.2680242 ,  0.46495205, -0.17071018],
           [ 0.92975325,  0.75471215,  1.18041485, -1.81148178],
           [-0.04067898, -2.31717149, -0.43814855,  0.83708957],
           [-0.07325125,  0.62176125, -0.70158709,  0.5102849 ]])




```python
data[names=='Bob']
```




    array([[-1.7629997 ,  0.08579372, -0.88277514, -1.14132668],
           [ 0.92975325,  0.75471215,  1.18041485, -1.81148178]])




```python
data[names=='Bob', 2:]
data[names=='Bob', 3:]
```




    array([[-1.14132668],
           [-1.81148178]])




```python
 ~(names=='Bob')#Not 비교연산결과이 반대
data[names!='Bob'] #값으로 출력
names!='Bob' #names에 저장된 각각의 자료와 'Bob'을 비교했을때 같지 않나?
```




    array([False,  True,  True, False,  True,  True])




```python
 ~(names=='Bob')#Not 비교연산결과이 반대

```




    array([False,  True,  True, False,  True,  True])




```python
data[~(names=='Bob')]

```




    array([[ 1.43614565,  1.27858212, -2.10666404, -0.30492433],
           [ 0.33015614,  0.2680242 ,  0.46495205, -0.17071018],
           [-0.04067898, -2.31717149, -0.43814855,  0.83708957],
           [-0.07325125,  0.62176125, -0.70158709,  0.5102849 ]])




```python
cond=names=='Bob'
```


```python
cond
```




    array([ True, False, False,  True, False, False])




```python
~cond
```




    array([False,  True,  True, False,  True,  True])




```python
data[(~cond)]
```




    array([[ 1.43614565,  1.27858212, -2.10666404, -0.30492433],
           [ 0.33015614,  0.2680242 ,  0.46495205, -0.17071018],
           [-0.04067898, -2.31717149, -0.43814855,  0.83708957],
           [-0.07325125,  0.62176125, -0.70158709,  0.5102849 ]])




```python
names=='Bob'
names=='Will'
```




    array([False, False,  True, False, False,  True])




```python
mask=(names=='Bob') | (names=='Will') #| : or
data[mask] #이름이 밥이거나 윌인 사람의 data 추출
```




    array([[-1.7629997 ,  0.08579372, -0.88277514, -1.14132668],
           [ 0.33015614,  0.2680242 ,  0.46495205, -0.17071018],
           [ 0.92975325,  0.75471215,  1.18041485, -1.81148178],
           [-0.07325125,  0.62176125, -0.70158709,  0.5102849 ]])




```python
data
```




    array([[-1.7629997 ,  0.08579372, -0.88277514, -1.14132668],
           [ 1.43614565,  1.27858212, -2.10666404, -0.30492433],
           [ 0.33015614,  0.2680242 ,  0.46495205, -0.17071018],
           [ 0.92975325,  0.75471215,  1.18041485, -1.81148178],
           [-0.04067898, -2.31717149, -0.43814855,  0.83708957],
           [-0.07325125,  0.62176125, -0.70158709,  0.5102849 ]])




```python
data<0
```




    array([[ True, False,  True,  True],
           [False, False,  True,  True],
           [False, False, False,  True],
           [False, False, False,  True],
           [ True,  True,  True, False],
           [ True, False,  True, False]])




```python
data[data<0]=0
data
```




    array([[0.        , 0.08579372, 0.        , 0.        ],
           [1.43614565, 1.27858212, 0.        , 0.        ],
           [0.33015614, 0.2680242 , 0.46495205, 0.        ],
           [0.92975325, 0.75471215, 1.18041485, 0.        ],
           [0.        , 0.        , 0.        , 0.83708957],
           [0.        , 0.62176125, 0.        , 0.5102849 ]])




```python
#names에서 이름이 Will이 아닌 사람들에 대한 index를 추출하여
#data 배열의 해당 index 자료 값을 모두 10으로 변경해라
names
data
```




    array([[0.        , 0.08579372, 0.        , 0.        ],
           [1.43614565, 1.27858212, 0.        , 0.        ],
           [0.33015614, 0.2680242 , 0.46495205, 0.        ],
           [0.92975325, 0.75471215, 1.18041485, 0.        ],
           [0.        , 0.        , 0.        , 0.83708957],
           [0.        , 0.62176125, 0.        , 0.5102849 ]])




```python
data[names!="Will"]=10
data
```




    array([[10.        , 10.        , 10.        , 10.        ],
           [10.        , 10.        , 10.        , 10.        ],
           [ 0.33015614,  0.2680242 ,  0.46495205,  0.        ],
           [10.        , 10.        , 10.        , 10.        ],
           [10.        , 10.        , 10.        , 10.        ],
           [ 0.        ,  0.62176125,  0.        ,  0.5102849 ]])




```python
arr=np.zeros((8,4))
```


```python
for i in range(8):
    arr[i]=i+10
#arr[0]=10
```


```python
arr

```




    array([[10., 10., 10., 10.],
           [11., 11., 11., 11.],
           [12., 12., 12., 12.],
           [13., 13., 13., 13.],
           [14., 14., 14., 14.],
           [15., 15., 15., 15.],
           [16., 16., 16., 16.],
           [17., 17., 17., 17.]])




```python
arr[4] #벡터로
arr[[4]] #2차원
```




    array([[14., 14., 14., 14.]])




```python
arr[4,3] #4행 3 열 요소값 하나 출력
```




    14.0




```python
arr[[4,3]] #4행 , 3행 출력 
```




    array([[14., 14., 14., 14.],
           [13., 13., 13., 13.]])




```python
arr[[4,3,0,6]]#4행 3행 0행 6행 
```




    array([[14., 14., 14., 14.],
           [13., 13., 13., 13.],
           [10., 10., 10., 10.],
           [16., 16., 16., 16.]])




```python
arr[[-3]] #뒤에서부터 3번째
```




    array([[15., 15., 15., 15.]])




```python
arr[[-3,-5]]
```




    array([[15., 15., 15., 15.],
           [13., 13., 13., 13.]])



# reshape


```python
arr=np.arange(10,42).reshape(8,4)
arr
```




    array([[10, 11, 12, 13],
           [14, 15, 16, 17],
           [18, 19, 20, 21],
           [22, 23, 24, 25],
           [26, 27, 28, 29],
           [30, 31, 32, 33],
           [34, 35, 36, 37],
           [38, 39, 40, 41]])




```python
arr[[1,5,7,2]]
```




    array([[14, 15, 16, 17],
           [30, 31, 32, 33],
           [38, 39, 40, 41],
           [18, 19, 20, 21]])




```python
arr[[1,5,7,2],[0]] #저안에서 또 0번 열
```




    array([14, 30, 38, 18])




```python
arr[[1,5,7,2],[0,3,1,2]]  #행열맞춰서 출력
```




    array([14, 33, 39, 20])



# transpose 

: `.T`


```python
arr=np.arange(15).reshape((3,5))
arr
```




    array([[ 0,  1,  2,  3,  4],
           [ 5,  6,  7,  8,  9],
           [10, 11, 12, 13, 14]])




```python
arr.T #transpose
```




    array([[ 0,  5, 10],
           [ 1,  6, 11],
           [ 2,  7, 12],
           [ 3,  8, 13],
           [ 4,  9, 14]])




```python
arr.T.T
```




    array([[ 0,  1,  2,  3,  4],
           [ 5,  6,  7,  8,  9],
           [10, 11, 12, 13, 14]])




```python
np.dot(arr,arr.T) #행렬 곱셈 수행
```




    array([[ 30,  80, 130],
           [ 80, 255, 430],
           [130, 430, 730]])




```python
arr=np.arange(10)
arr
np.sqrt(arr)
np.exp(arr)
```




    array([1.00000000e+00, 2.71828183e+00, 7.38905610e+00, 2.00855369e+01,
           5.45981500e+01, 1.48413159e+02, 4.03428793e+02, 1.09663316e+03,
           2.98095799e+03, 8.10308393e+03])




```python
np.random.randn(8)
```




    array([-0.66373468, -0.40966066,  1.27808613, -0.80337872,  0.70335419,
           -0.24415118,  0.98030434, -0.00624601])




```python
x=np.random.randn(8)
y=np.random.randn(8)
```


```python
x
```




    array([-0.37945806,  0.67408706, -1.20618862, -0.1899834 , -0.02765377,
           -0.98120231, -0.16186896, -0.79138309])




```python
y
```




    array([-0.66125938, -0.04438565, -0.24468404, -0.23724064,  0.2108472 ,
            0.89879999, -1.09109861, -0.80624488])




```python
np.maximum(x,y) #각 배열의 두 원소 비교해서 더 큰값
```




    array([-0.37945806,  0.67408706, -0.24468404, -0.1899834 ,  0.2108472 ,
            0.89879999, -0.16186896, -0.79138309])




```python
arr=np.random.randn(7)*5
arr
```




    array([-2.85673795,  0.48441562,  4.96684851,  2.68446797,  5.26242124,
           -0.79333451,  4.54008589])




```python
np.modf(arr) #정수 실수로 분리
#출력 튜플 
```




    (array([-0.85673795,  0.48441562,  0.96684851,  0.68446797,  0.26242124,
            -0.79333451,  0.54008589]),
     array([-2.,  0.,  4.,  2.,  5., -0.,  4.]))




```python
remainder, whole_part=np.modf(arr)
```


```python
remainder
```




    array([-0.85673795,  0.48441562,  0.96684851,  0.68446797,  0.26242124,
           -0.79333451,  0.54008589])




```python
points=np.arange(-5,5,0.01)
points.shape
xs,ys=np.meshgrid(points,points)
#두개의 1차원 배열을 입력받아서 가능한 모든 (x,y) 짝을 만들 수 있는 2차원 배열 2개를 리턴
```


```python
xs.shape
```




    (1000, 1000)




```python
z=np.sqrt(xs**2+ys**2)
z
```




    array([[7.07106781, 7.06400028, 7.05693985, ..., 7.04988652, 7.05693985,
            7.06400028],
           [7.06400028, 7.05692568, 7.04985815, ..., 7.04279774, 7.04985815,
            7.05692568],
           [7.05693985, 7.04985815, 7.04278354, ..., 7.03571603, 7.04278354,
            7.04985815],
           ...,
           [7.04988652, 7.04279774, 7.03571603, ..., 7.0286414 , 7.03571603,
            7.04279774],
           [7.05693985, 7.04985815, 7.04278354, ..., 7.03571603, 7.04278354,
            7.04985815],
           [7.06400028, 7.05692568, 7.04985815, ..., 7.04279774, 7.04985815,
            7.05692568]])



사각형 영역 생성
(x,y) = (0,0),(0,1), ... ,(2,4) #그리드 포인트를 만들어 주는 함수 만들어 주는 함수


```python
xarr=np.array([1.1,1.2,1.3,1.4,1.5])
```


```python
yarr=np.array([2.1,2.2,2.3,2.4,2.5])
```


```python
cond=np.array([True, False,True,True,False])
```


```python
list(zip(xarr,yarr,cond))

```




    [(1.1, 2.1, True),
     (1.2, 2.2, False),
     (1.3, 2.3, True),
     (1.4, 2.4, True),
     (1.5, 2.5, False)]




```python
np.where(cond,xarr,yarr) #cond 참이면 xarr, 거짓이면 yarr
```




    array([1.1, 2.2, 1.3, 1.4, 2.5])




```python
arr=np.random.randn(4,4)
arr
```




    array([[ 1.20411969,  0.51289188, -0.47757132,  0.40252123],
           [ 0.51805521,  0.40610199, -3.59218096,  0.7086684 ],
           [ 0.12203948,  1.19231465,  0.38678359, -0.62112551],
           [-0.16908819,  0.3816162 , -0.70910204, -0.42268181]])




```python
np.where(arr>1,1,0)

```




    array([[1, 0, 0, 0],
           [0, 0, 0, 0],
           [0, 1, 0, 0],
           [0, 0, 0, 0]])



arr.cumsum() 누적합
arr.cumprod() 누적곱 마지막 값이 팩토리얼



```python
arr=np.arange(1,10).reshape(3,3)
print(arr.cumsum())
print("="*50)
print(arr.cumsum(axis=0)) #행방향으로 이동 위-> 아래
print("="*50)
print(arr.cumsum(axis=1))#열방향으로 이동 좌-> 우
```

    [ 1  3  6 10 15 21 28 36 45]
    ==================================================
    [[ 1  2  3]
     [ 5  7  9]
     [12 15 18]]
    ==================================================
    [[ 1  3  6]
     [ 4  9 15]
     [ 7 15 24]]



```python
arr=np.random.randn(100)
arr
arr.mean()
arr.std()
```




    1.0948840744865722




```python
#양수의 합
arr[arr>0].sum()

```




    43.03447118375433




```python
#양수는 1로 음수는 -1로
arr=np.where(arr>0,1,-1)
```


```python
arr
```




    array([ 1, -1,  1, -1,  1,  1,  1,  1,  1, -1, -1,  1, -1, -1, -1, -1,  1,
           -1, -1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, -1,  1, -1,  1, -1,
            1,  1, -1,  1,  1,  1, -1, -1, -1,  1,  1,  1, -1, -1, -1, -1,  1,
           -1, -1,  1,  1, -1,  1, -1,  1, -1, -1, -1, -1,  1, -1, -1,  1,  1,
            1, -1,  1,  1, -1, -1,  1, -1,  1, -1,  1,  1,  1,  1, -1,  1,  1,
           -1, -1, -1,  1,  1, -1, -1,  1,  1, -1,  1, -1, -1, -1, -1])




```python
bools=np.array([False,False,True,False])
```


```python
bools.any() #어느 하나라도 True가 있으면 True가 출력
```




    True




```python
bools.all() 
```




    False




```python
arr=np.random.randn(6)
arr
```




    array([ 0.72698268,  1.06781208, -0.3152232 ,  0.43618752, -1.82380539,
           -0.71851977])




```python
arr.sort()
arr
```




    array([-1.82380539, -0.71851977, -0.3152232 ,  0.43618752,  0.72698268,
            1.06781208])




```python
arr=np.random.randn(5,3)
arr
```




    array([[ 1.0453296 , -0.60761059,  0.1600552 ],
           [ 0.2638825 ,  2.76554664, -1.05415139],
           [-0.01700882, -0.22844088, -0.17036186],
           [-0.92696854,  0.56610445, -0.9183061 ],
           [-0.86368295, -0.77736636,  0.86923952]])




```python
arr.sort() #왼쪽에서 오른쪽ㅇ로 정렬
```


```python
arr
```




    array([[-0.60761059,  0.1600552 ,  1.0453296 ],
           [-1.05415139,  0.2638825 ,  2.76554664],
           [-0.22844088, -0.17036186, -0.01700882],
           [-0.92696854, -0.9183061 ,  0.56610445],
           [-0.86368295, -0.77736636,  0.86923952]])




```python
arr.sort(axis=0) #오름차순 ( 행방향으로) 디폴트가 열방향
```


```python
arr
```




    array([[-1.05415139, -0.9183061 , -0.01700882],
           [-0.92696854, -0.77736636,  0.56610445],
           [-0.86368295, -0.17036186,  0.86923952],
           [-0.60761059,  0.1600552 ,  1.0453296 ],
           [-0.22844088,  0.2638825 ,  2.76554664]])




```python
arr[::-1] #넘파이는 별도로 내림차순 정렬이 없음 오름차순 한다음에 뒤에서 부터 참조할 것 

```




    array([[-0.22844088,  0.2638825 ,  2.76554664],
           [-0.60761059,  0.1600552 ,  1.0453296 ],
           [-0.86368295, -0.17036186,  0.86923952],
           [-0.92696854, -0.77736636,  0.56610445],
           [-1.05415139, -0.9183061 , -0.01700882]])




```python
names=np.array(['Bob','Joe','Will','Bob','Joe','Will'])
```


```python
np.unique(names) #유일한 문자열 추출
```




    array(['Bob', 'Joe', 'Will'], dtype='<U4')




```python
sorted(set(names))
```




    ['Bob', 'Joe', 'Will']




```python
arr=np.array([6,0,0,3,2,5])
```


```python
np.in1d(arr,[2,3,6]) #arr의 각 원소가 [2,3,6]의 원소에 포함되어 있는지 여부 출력
```




    array([ True, False, False,  True,  True, False])




```python
a=np.array([1,2,3])
b=np.array([10,20,30])
```


```python
2*a+b
(a==2)&(b>10)
```




    array([False,  True, False])




```python
a=np.arange(6).reshape(2,3)
len(a) #행의 개수
print(len(a[0])) #열의 개수
np.shape(a)

```

    3





    (2, 3)



리스트 : 1차원
리스트의 리스트: 2차원
라스트의 리스트의 리스트: 3차원 배열



```python
d=np.arange(10,34).reshape(2,3,4)
d
```




    array([[[10, 11, 12, 13],
            [14, 15, 16, 17],
            [18, 19, 20, 21]],
    
           [[22, 23, 24, 25],
            [26, 27, 28, 29],
            [30, 31, 32, 33]]])




```python
len(d)  #가장 바깥쪽 대괄호 안에 요소가 2개 있음
len(d[0]) #3 , 바까쪽 대괄호 안에 요소가 3개 있음
len(d[0][0]) #4 , 가장 안쪽 요소의 개수 depth

np.shape(d)[0]
```




    2




```python
d.ndim
```




    3




```python
a=np.arange(6).reshape(2,3)
a 
#마지막 행의 마지막 열을 출력
```




    array([[0, 1, 2],
           [3, 4, 5]])




```python
a[1][2]
a[-1][-1]
```




    5




```python
x=np.array([1,2.0])
x.dtype
```




    dtype('float64')




```python
x=np.array([1,2],dtype="f")
```


```python
x.dtype
```




    dtype('float32')




```python
x
```




    array([1., 2.], dtype=float32)




```python
np.inf
```




    inf




```python
a=np.array([0,1,-1,0])
b=np.array([1,0,0,0])
```


```python
np.log
```




    <ufunc 'log'>




```python
np.linspace(0,100,5) #0부터 100까지 5개 수를 구간으로 나눠 출력
```




    array([  0.,  25.,  50.,  75., 100.])




```python
a=np.arange(12)
print(a.reshape(3,4))
a.reshape(3,-1)
```

    [[ 0  1  2  3]
     [ 4  5  6  7]
     [ 8  9 10 11]]





    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11]])




```python
a.reshape(2,2,-1) #2*2*3차원 배열
```




    array([[[ 0,  1,  2],
            [ 3,  4,  5]],
    
           [[ 6,  7,  8],
            [ 9, 10, 11]]])




```python
a=np.arange(12)
a.reshape(2,2,3)
```




    array([[[ 0,  1,  2],
            [ 3,  4,  5]],
    
           [[ 6,  7,  8],
            [ 9, 10, 11]]])




```python
#3차원 -> 1차원 
#a.reshape(12,)
#a.flatten()
a.ravel()
```




    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])




```python
x=np.arange(5).reshape(1,5)
x.shape
```




    (1, 5)




```python
x=np.arange(5)
x
print(x[:, np.newaxis]) #1차원 증가 시킴 (5) -> (5,1)
```

    [[0]
     [1]
     [2]
     [3]
     [4]]



```python
#행의 수가 같은 배열을 옆으로 연결 (열이 증가)
a=np.ones((2,3))
b=np.zeros((2,2))
```


```python
print(a)
print(b)
```

    [[1. 1. 1.]
     [1. 1. 1.]]
    [[0. 0.]
     [0. 0.]]



```python
np.hstack([a,b]) #좌우로 합치기
```




    array([[1., 1., 1., 0., 0.],
           [1., 1., 1., 0., 0.]])




```python
b=np.zeros((2,3))
np.vstack([a,b]) #세로로
```




    array([[1., 1., 1.],
           [1., 1., 1.],
           [0., 0., 0.],
           [0., 0., 0.]])




```python
#tile: 동일한 배열 반복하여 연결

np.tile(a,(3,2)) #위 -> 아래 방향으로 3번, 좌->우 방향으로 2번 반복
```


      File "<ipython-input-220-0798549029b0>", line 3
        np.tile(a,,(3,2))
                  ^
    SyntaxError: invalid syntax




```python
x=np.arange(5,14).reshape(3,3)
x
```




    array([[ 5,  6,  7],
           [ 8,  9, 10],
           [11, 12, 13]])




```python
np.percentile(x,0) #최소값
np.percentile(x,25) #1, 1사분위수는 25% 백분위수와 같아
np.percentile(x,50) #2
np.percentile(x,75) #3
np.percentile(x,100) #4
```




    13.0




```python
np.random.seed(111)
```


```python
np.random.rand(5) #0이상 1미만 난수
```




    array([0.61217018, 0.16906975, 0.43605902, 0.76926247, 0.2953253 ])




```python
x=np.arange(10)
```


```python
x
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
np.random.shuffle(x)
```


```python
x
```




    array([6, 5, 3, 0, 9, 2, 4, 1, 7, 8])




```python
arr1=np.arange(11,20)
```


```python
np.random.choice(arr1,5)
```




    array([13, 16, 17, 19, 16])




```python
np.random.choice(arr1,5,replace=True)
```




    array([17, 16, 19, 17, 13])




```python
np.random.choice(10,5) #10은 np.arange(10)을 의미함
```




    array([6, 4, 3, 7, 9])




```python
np.random.randint(10)
```




    3




```python
np.unique([1,1,3,3,5])
```




    array([1, 3, 5])




```python
idx, cnt=np.unique([1,1,3,3,5], return_counts=True) #unique한 각각의 자료가 몇개인지

```




    (array([1, 3, 5]), array([2, 2, 1], dtype=int64))




```python
idx[1]
cnt[1]
```




    2




```python
np.bincount([1,1,3,3,5], minlength=7)  #minlength=7이므로 0~6 카운트
#bincount는 0부터 센다
```




    array([0, 2, 0, 2, 0, 1, 0], dtype=int64)




```python
num=np.random.randint(46)
num
```




    28




```python
np.random.randint(1,46,size=7)
```




    array([28, 14, 16, 39, 37, 36, 37])




```python
pip install jupyter_contrib_nbextensions
```

```python
! jupyter contrib nbextension install --user
```



# 연습문제

## iris 유클리디안

```python
from sklearn.datasets import load_iris
```


```python
iris = load_iris()
#첫번째 꽃 데이터와 가장 유사한 꽃 데이터 &유클리디안
iris.data[0,:]
```




    array([5.1, 3.5, 1.4, 0.2])




```python
# 1. 파이썬 연습문제
# - 입력 받은 정수가 음수인지 양수인지 0인지 알려주세요.
# - 'hello'를 지정한 횟수(0 <= n <= 3)만큼 출력해 보세요.
# - 0~9사이의 정수를 거꾸로 출력해 보세요.
# - 임의의 리스트를 생성한 후, 리스트를 거꾸로 출력하는 반복문을 만들어 보세요.
# - 리스트를 출력하면서 앞에 일련번호를 붙여주세요. 
# # 0 2
# # 1 4
# # 2 6
# - 리스트에서 중복 값을 제거해 보세요.
# ns = [1, 3, 5, 1, 3, 5, 1, 3, 5]

a=int(input())
if a == 0:
    print("0")
elif a>0:
    print("양수")
else:
     print("음수")

n=2
print("hello"*n)

print(list(range(9,-1,-1)))

mylist=["kim","ga","won"]
print(list(reversed(mylist)))

for i in range(len(mylist)):
    print(str(i) +" "+ mylist[i])
    
ns = [1, 3, 5, 1, 3, 5, 1, 3, 5]
set(ns)
```

    4
    양수
    hellohello
    [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
    ['won', 'ga', 'kim']
    0 kim
    1 ga
    2 won



    {1, 3, 5}




```python

# 2. numpy 연습문제
# 1)랜덤하게 실수로 이루어진 5 x 6 형태의 데이터 행렬을 만들고 이 데이터에 대해 다음과 같은 값을 구한다.
# -전체의 최댓값
# -각 행의 합
# -각 행의 최댓값
# -각 열의 평균
# -각 열의 최솟값
arr=np.random.randint(50,size=(5,6))
print(arr)
print("="*50)

print(arr.max()) #전체의 최댓값
print(arr.sum(axis=0)) #각 행의 합
print(arr.max(axis=0)) #각 행의 최댓값
print(arr.mean(axis=1)) #각 열의 평균
print(arr.min(axis=1)) #각 열의 최솟값
```

    [[10 11  3  7 49 47]
     [ 9  1 14 44  0 48]
     [47 33  9 25 32 49]
     [37  3  2  2 13 31]
     [23 23  1 27 43 33]]
    ==================================================
    49
    [126  71  29 105 137 208]
    [47 33 14 44 49 49]
    [21.16666667 19.33333333 32.5        14.66666667 25.        ]
    [3 0 9 2 1]



```python
# 2)다음 행렬과 같은 행렬이 있다.
# m = np.array([[ 0,  1,  2,  3,  4],
#             [ 5,  6,  7,  8,  9],
#             [10, 11, 12, 13, 14]])
# -이 행렬에서 값 7 을 인덱싱한다.
# -이 행렬에서 값 14 을 인덱싱한다.
# -이 행렬에서 배열 [6, 7] 을 슬라이싱한다.
# -이 행렬에서 배열 [7, 12] 을 슬라이싱한다.
# -이 행렬에서 배열 [[3, 4], [8, 9]] 을 슬라이싱한다.
m = np.array([[ 0,  1,  2,  3,  4],
             [ 5,  6,  7,  8,  9],
             [10, 11, 12, 13, 14]])

print(np.where(m==7))
print(np.where(m==14))

print(m[1,1:3])
print(m[1:,2])
m[0:2,3:]

```

    (array([1], dtype=int64), array([2], dtype=int64))
    (array([2], dtype=int64), array([4], dtype=int64))
    [6 7]
    [ 7 12]





    array([[3, 4],
           [8, 9]])




```python
# 3) 지금까지 공부한 명령어를 사용하여 다음과 같은 배열을 만들어라.
# (코드를 효율적으로)
# array([[   0.,    0.,    0.,    1.,    1.],
#        [   0.,    0.,    0.,    1.,    1.],
#        [   0.,    0.,    0.,    1.,    1.],
#        [  10.,   20.,   30.,   40.,   50.],
#        [  60.,   70.,   80.,   90.,  100.],
#        [ 110.,  120.,  130.,  140.,  150.],
#        [   0.,    0.,    0.,    1.,    1.],
#        [   0.,    0.,    0.,    1.,    1.],
#        [   0.,    0.,    0.,    1.,    1.],
#        [  10.,   20.,   30.,   40.,   50.],
#        [  60.,   70.,   80.,   90.,  100.],
#        [ 110.,  120.,  130.,  140.,  150.]])

arr1=np.zeros((3,3))
arr2=np.ones((3,2))
arr3=np.arange(10,160,10).reshape(3,5)
temp=np.hstack([arr1,arr2])
np.vstack([temp,arr3,temp,arr3])

```




    array([[  0.,   0.,   0.,   1.,   1.],
           [  0.,   0.,   0.,   1.,   1.],
           [  0.,   0.,   0.,   1.,   1.],
           [ 10.,  20.,  30.,  40.,  50.],
           [ 60.,  70.,  80.,  90., 100.],
           [110., 120., 130., 140., 150.],
           [  0.,   0.,   0.,   1.,   1.],
           [  0.,   0.,   0.,   1.,   1.],
           [  0.,   0.,   0.,   1.,   1.],
           [ 10.,  20.,  30.,  40.,  50.],
           [ 60.,  70.,  80.,  90., 100.],
           [110., 120., 130., 140., 150.]])




```python

# 4) 다음 행렬과 같은 배열이 있다.
# x = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
#              11, 12, 13, 14, 15, 16, 17, 18, 19, 20])
# -이 배열에서 3의 배수를 찾아라.
# -이 배열에서 4로 나누면 1이 남는 수를 찾아라.
# -이 배열에서 3으로 나누면 나누어지고 4로 나누면 1이 남는 수를 찾아라.
x = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
             11, 12, 13, 14, 15, 16, 17, 18, 19, 20])

x[x%3==0]
x[x%4==1] 
x[(x%3==0 )&(x%4==1)]

```




    array([9])




```python
import random
head=0
tail=0
# 5) 
# -동전을 10번 던져 앞면(숫자 1)과 뒷면(숫자 0)이 나오는 가상 실험을 파이썬으로 작성한다.
coin=[1,0]
choice=0
for i in range(10):
    print(random.choice(coin))

print("="*50)
# -주사위를 100번 던져서 나오는 숫자의 평균을 구하라.
dice=[1,2,3,4,5,6]
num=0
for i in range(100):
    num+=random.choice(dice)
print(num/100)


```

    1
    0
    1
    1
    0
    1
    0
    0
    1
    0
    ==================================================
    3.62



```python
# 6)다음 배열은 첫번째 행(row)에 학번, 두번째 행에 영어 성적, 세번째 행에 수학 성적을 적은 배열이다. 
# 영어 성적을 기준으로 각 열(column)을 재정렬하라.
arr=np.array([[  1,    2,    3,    4],
       [ 46,   99,  100,   71],
       [ 81,   59,   90,  100]])
eng=arr[1,:]
np.argsort(eng)
arr[:,np.argsort(eng)]


```




    array([[  1,   4,   2,   3],
           [ 46,  71,  99, 100],
           [ 81, 100,  59,  90]])




```python
#3. iris data 유사 데이터 추출
from sklearn.datasets import load_iris  # 사이킷런 패키지 임포트
iris = load_iris()  # 데이터 로드
#print(iris.DESCR) 150
dis=[]
a=iris.data[0, :]  # 첫 번째 꽃의 데이터
a - iris.data[i,:]
for i in range(1,150):
    dis.append(sqrt(sum((a - iris.data[i,:])**2)))

print(min(dis))
print(dis.index(min(dis))+1)
#17번째 꽃이 0.99999... 로 가장 비슷하다.
    
```

    0.09999999999999998
    17



